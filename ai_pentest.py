#!/usr/bin/env python3
import nmap
import requests
import whois
import shodan
import sys
import os
import json
import argparse
import socket
from datetime import datetime
from rich.console import Console
from rich.progress import Progress
from rich.panel import Panel
from rich.table import Table
from rich.prompt import Prompt, Confirm
from pyfiglet import Figlet
from colorama import Fore, Style, init

class PentestAutomation:
    def __init__(self, target=None, scope=None, modules=None, output_format=None, verbose=False, auth_token=None):
        self.target = target
        self.scope = scope
        self.modules = modules or []
        self.output_format = output_format
        self.verbose = verbose
        self.auth_token = auth_token
        self.console = Console()
        self.results = {
            "recon": {},
            "vulns": [],
            "exploits": [],
            "post_exploit": []
        }
        init(autoreset=True)
        
    def print_verbose(self, message):
        """Print verbose messages if verbose mode is enabled"""
        if self.verbose:
            self.console.print(f"[cyan][VERBOSE] {message}[/cyan]")

    def banner(self):
        f = Figlet(font='slant')
        self.console.print(Panel.fit(f.renderText('AI PenTest'), title="Welcome", border_style="blue"))
        
    def show_help(self):
        """Display help information about available commands and modules"""
        help_table = Table(title="Available Commands and Modules")
        help_table.add_column("Command/Module", style="cyan")
        help_table.add_column("Description", style="green")
        
        # Commands
        help_table.add_row("--target", "Specify target IP/Domain")
        help_table.add_row("--scope", "Set scope (network/webapp/api)")
        help_table.add_row("--modules", "Select modules to run (comma-separated)")
        help_table.add_row("--output", "Set output format (pdf/html/json)")
        help_table.add_row("--verbose", "Enable verbose output")
        help_table.add_row("--help", "Show this help message")
        
        # Modules
        help_table.add_row("recon", "Passive and active reconnaissance")
        help_table.add_row("vuln_scan", "Vulnerability scanning")
        help_table.add_row("exploit", "Exploitation attempts")
        help_table.add_row("post_exploit", "Post-exploitation tasks")
        help_table.add_row("cleanup", "Cleanup operations")
        
        self.console.print(help_table)

    def validate_target(self, target):
        """Validate target IP/Domain"""
        try:
            socket.gethostbyname(target)
            return True
        except socket.gaierror:
            self.console.print("[red]Invalid target IP/Domain[/red]")
            return False

    def legal_compliance_check(self):
        """Verify authorization for the target"""
        try:
            if not self.auth_token:
                self.console.print("[red]Error: No authorization token provided[/red]")
                return False
                
            # Validate authorization token format
            if not self.validate_auth_token(self.auth_token):
                self.console.print("[red]Error: Invalid authorization token format[/red]")
                return False

            # Add more sophisticated authorization checks here
            self.print_verbose(f"Performing authorization check for target: {self.target}")
            
            # Example: Check against allowed targets database
            allowed_targets = self.load_allowed_targets()
            if self.target not in allowed_targets:
                self.console.print("[red]Target not in allowed targets list[/red]")
                return False
                
            return True
        except Exception as e:
            self.console.print(f"[red]Authorization verification failed: {str(e)}[/red]")
            return False

    def load_auth_tokens(self):
        """Load authorization tokens from the JSON file"""
        try:
            with open('auth_tokens.json', 'r') as f:
                return json.load(f)
        except Exception as e:
            self.console.print(f"[red]Error loading auth tokens: {str(e)}[/red]")
            return {"tokens": []}

    def list_available_tokens(self):
        """Display available authorization tokens"""
        auth_data = self.load_auth_tokens()
        
        # Create a table to display tokens
        table = Table(title="Available Authorization Tokens")
        table.add_column("Token", style="cyan")
        table.add_column("Description", style="green")
        table.add_column("Allowed Targets", style="yellow")
        
        for token_info in auth_data.get("tokens", []):
            targets = ", ".join(token_info.get("allowed_targets", []))
            table.add_row(
                token_info.get("token", ""),
                token_info.get("description", ""),
                targets
            )
        
        self.console.print(table)

    def validate_auth_token(self, token):
        """Validate the authorization token against the stored tokens"""
        auth_data = self.load_auth_tokens()
        
        for token_info in auth_data.get("tokens", []):
            if token_info.get("token") == token:
                allowed_targets = token_info.get("allowed_targets", [])
                # Check if token allows all targets or specific target is allowed
                if "*" in allowed_targets or self.target in allowed_targets:
                    return True
        return False

    def get_auth_token(self):
        """Get authorization token with improved user interface"""
        # First try to get from environment variable
        auth_token = os.getenv('PENTEST_AUTH_TOKEN')
        
        if not auth_token:
            self.console.print("\n[yellow]Available Authorization Tokens:[/yellow]")
            self.list_available_tokens()
            
            # Let user choose from available tokens
            auth_data = self.load_auth_tokens()
            available_tokens = [t.get("token") for t in auth_data.get("tokens", [])]
            
            if available_tokens:
                token_number = Prompt.ask(
                    "\nEnter token number",
                    choices=[str(i+1) for i in range(len(available_tokens))],
                    default="1"
                )
                auth_token = available_tokens[int(token_number) - 1]
            else:
                self.console.print("[red]No authorization tokens available![/red]")
                return None
        
        self.auth_token = auth_token
        return auth_token

    def passive_recon(self):
        """Perform passive reconnaissance"""
        self.console.print("[yellow]Starting Passive Reconnaissance...[/yellow]")
        
        try:
            # DNS Information
            self.print_verbose("Gathering DNS information...")
            dns_info = socket.gethostbyname_ex(self.target)
            self.results["recon"]["dns"] = dns_info

            # WHOIS Information
            self.print_verbose("Performing WHOIS lookup...")
            whois_info = whois.whois(self.target)
            self.results["recon"]["whois"] = whois_info

            # HTTP Information
            self.print_verbose("Gathering HTTP information...")
            try:
                response = requests.get(f"http://{self.target}", timeout=10)
                self.results["recon"]["http_status"] = response.status_code
                self.results["recon"]["http_headers"] = dict(response.headers)
                self.results["recon"]["server_info"] = response.headers.get('Server')
            except requests.exceptions.RequestException as e:
                self.print_verbose(f"HTTP request failed: {str(e)}")
                self.results["recon"]["http_status"] = "Connection Failed"

            # Shodan Integration
            if os.getenv('SHODAN_API_KEY'):
                self.print_verbose("Querying Shodan...")
                api = shodan.Shodan(os.getenv('SHODAN_API_KEY'))
                try:
                    shodan_info = api.host(self.target)
                    self.results["recon"]["shodan"] = shodan_info
                except Exception as e:
                    self.print_verbose(f"Shodan query failed: {str(e)}")

            return True
        except Exception as e:
            self.console.print(f"[red]Passive reconnaissance failed: {str(e)}[/red]")
            return False

    def active_recon(self):
        """Perform active reconnaissance"""
        self.console.print("[yellow]Starting Active Reconnaissance...[/yellow]")
        
        try:
            # Port Scanning
            self.print_verbose("Starting port scan...")
            nm = nmap.PortScanner()
            scan_results = nm.scan(self.target, arguments="-sV -sS -T4 -F")
            self.results["recon"]["nmap"] = scan_results

            # Service Version Detection
            if 'scan' in scan_results:
                for host in scan_results['scan']:
                    if 'tcp' in scan_results['scan'][host]:
                        for port in scan_results['scan'][host]['tcp']:
                            service_info = scan_results['scan'][host]['tcp'][port]
                            self.print_verbose(f"Port {port}: {service_info.get('name', 'unknown')} "
                                            f"({service_info.get('version', 'unknown')})")

            return True
        except Exception as e:
            self.console.print(f"[red]Active reconnaissance failed: {str(e)}[/red]")
            return False

    def vulnerability_scan(self):
        """Perform vulnerability scanning"""
        self.console.print("[yellow]Starting Vulnerability Scan...[/yellow]")
        
        try:
            self.print_verbose("Initializing vulnerability scanner...")
            
            # Web Application Vulnerabilities
            if 'webapp' in self.scope:
                self.print_verbose("Scanning for web vulnerabilities...")
                web_vulns = self.scan_web_vulnerabilities()
                self.results["vulns"].extend(web_vulns)

            # Network Vulnerabilities
            if 'network' in self.scope:
                self.print_verbose("Scanning for network vulnerabilities...")
                network_vulns = self.scan_network_vulnerabilities()
                self.results["vulns"].extend(network_vulns)

            # API Vulnerabilities
            if 'api' in self.scope:
                self.print_verbose("Scanning for API vulnerabilities...")
                api_vulns = self.scan_api_vulnerabilities()
                self.results["vulns"].extend(api_vulns)

            return True
        except Exception as e:
            self.console.print(f"[red]Vulnerability scanning failed: {str(e)}[/red]")
            return False

    def scan_web_vulnerabilities(self):
        """Scan for web application vulnerabilities"""
        vulns = []
        # Add web vulnerability scanning logic here
        return vulns

    def scan_network_vulnerabilities(self):
        """Scan for network vulnerabilities"""
        vulns = []
        # Add network vulnerability scanning logic here
        return vulns

    def scan_api_vulnerabilities(self):
        """Scan for API vulnerabilities"""
        vulns = []
        # Add API vulnerability scanning logic here
        return vulns

    def exploitation(self):
        """Perform exploitation if vulnerabilities are found"""
        if not self.results["vulns"]:
            self.console.print("[yellow]No vulnerabilities found to exploit[/yellow]")
            return False

        self.console.print("[yellow]Starting Exploitation Phase...[/yellow]")
        self.print_verbose(f"Found {len(self.results['vulns'])} potential vulnerabilities")
        
        for vuln in self.results["vulns"]:
            self.print_verbose(f"Attempting to exploit: {vuln.get('name', 'Unknown vulnerability')}")
            # Add exploitation logic here
            
        return True

    def post_exploitation(self):
        """Perform post-exploitation tasks"""
        self.console.print("[yellow]Starting Post-Exploitation Phase...[/yellow]")
        
        if not self.results["exploits"]:
            self.print_verbose("No successful exploits to perform post-exploitation")
            return False

        # Add post-exploitation logic here
        return True

    def cleanup(self):
        """Perform cleanup operations"""
        self.console.print("[yellow]Starting Cleanup Phase...[/yellow]")
        
        try:
            self.print_verbose("Removing temporary files...")
            # Add cleanup logic here
            
            self.print_verbose("Closing connections...")
            # Add connection cleanup logic here
            
            return True
        except Exception as e:
            self.console.print(f"[red]Cleanup failed: {str(e)}[/red]")
            return False

    def generate_report(self):
        """Generate the final report"""
        self.console.print("[yellow]Generating Report...[/yellow]")
        
        report_data = {
            "target": self.target,
            "scan_date": datetime.now().isoformat(),
            "scope": self.scope,
            "modules_run": self.modules,
            "results": self.results
        }

        filename = f"pentest_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        
        if self.output_format == 'json':
            with open(f"{filename}.json", 'w') as f:
                json.dump(report_data, f, indent=4)
                
        elif self.output_format == 'html':
            self.generate_html_report(report_data, filename)
            
        elif self.output_format == 'pdf':
            self.generate_pdf_report(report_data, filename)

        self.console.print(f"[green]Report generated: {filename}.{self.output_format}[/green]")
        return True

    def generate_html_report(self, data, filename):
        """Generate HTML report"""
        # Add HTML report generation logic here
        pass

    def generate_pdf_report(self, data, filename):
        """Generate PDF report"""
        # Add PDF report generation logic here
        pass

    def load_allowed_targets(self):
        """Load allowed targets from configuration"""
        # This would typically load from a secure configuration file
        # For demo purposes, returning a sample list
        return ["example.com", "test.local", "127.0.0.1"]

    def run(self):
        """Main execution flow"""
        self.banner()

        if not self.target:
            self.target = Prompt.ask("Enter target (IP/Domain)")
        
        if not self.validate_target(self.target):
            return False

        if not self.scope:
            self.scope = Prompt.ask("Enter scope", choices=["network", "webapp", "api"])
            
        if not self.modules:
            available_modules = ["recon", "vuln_scan", "exploit", "post_exploit", "cleanup"]
            self.modules = Prompt.ask("Enter modules (comma-separated)", default=",".join(available_modules))
            if isinstance(self.modules, str):
                self.modules = [m.strip() for m in self.modules.split(",")]

        if not self.output_format:
            self.output_format = Prompt.ask("Enter output format", choices=["pdf", "html", "json"], default="json")

        # Get and validate authorization token
        if not self.auth_token:
            self.get_auth_token()

        # Legal Compliance Check
        if not self.legal_compliance_check():
            self.console.print("[red]Terminating: Legal compliance check failed[/red]")
            return False

        # Execute phases
        phases = [
            ("Passive Reconnaissance", self.passive_recon, "recon"),
            ("Active Reconnaissance", self.active_recon, "recon"),
            ("Vulnerability Scanning", self.vulnerability_scan, "vuln_scan"),
            ("Exploitation", self.exploitation, "exploit"),
            ("Post-Exploitation", self.post_exploitation, "post_exploit"),
            ("Cleanup", self.cleanup, "cleanup"),
            ("Report Generation", self.generate_report, None)
        ]

        with Progress() as progress:
            task = progress.add_task("[cyan]Running penetration test...", total=len(phases))

            for phase_name, phase_func, module in phases:
                if module is None or module in self.modules:
                    self.console.print(f"\n[blue]Executing {phase_name}...[/blue]")
                    if not phase_func():
                        self.console.print(f"[red]{phase_name} failed![/red]")
                    else:
                        self.print_verbose(f"{phase_name} completed successfully")
                progress.update(task, advance=1)

        self.console.print("[green]Penetration test completed![/green]")
        return True

def main():
    parser = argparse.ArgumentParser(description='AI-Powered Penetration Testing Tool')
    parser.add_argument('--target', help='Target IP/Domain')
    parser.add_argument('--scope', choices=['network', 'webapp', 'api'], help='Scope of testing')
    parser.add_argument('--modules', help='Modules to run (comma-separated)')
    parser.add_argument('--output', choices=['pdf', 'html', 'json'], default='json', help='Output format')
    parser.add_argument('--verbose', action='store_true', help='Enable verbose output')
    parser.add_argument('--help-modules', action='store_true', help='Show detailed help about available modules')
    parser.add_argument('--auth-token', help='Authorization token (format: AUTH-YYYY-MM-DD-XXXX)')
    
    args = parser.parse_args()
    
    if args.help_modules:
        pentest = PentestAutomation()
        pentest.show_help()
        return
        
    modules = args.modules.split(',') if args.modules else None
    
    pentest = PentestAutomation(
        target=args.target,
        scope=args.scope,
        modules=modules,
        output_format=args.output,
        verbose=args.verbose,
        auth_token=args.auth_token
    )
    
    pentest.run()

if __name__ == "__main__":
    main()
