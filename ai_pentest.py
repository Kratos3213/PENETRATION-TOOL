#!/usr/bin/env python3
import nmap
import requests
import whois
import shodan
import sys
import os
import json
import argparse
import socket
from datetime import datetime
from rich.console import Console
from rich.progress import Progress
from rich.panel import Panel
from rich.table import Table
from rich.prompt import Prompt, Confirm
from pyfiglet import Figlet
from colorama import Fore, Style, init

class PentestAutomation:
    def __init__(self, target: str = None, scope: str = None, modules: list = None, output_format: str = None, verbose: bool = False, auth_token: str = None):
        """
        Initialize the PentestAutomation class.
        Args:
            target (str): Target IP or domain.
            scope (str): Scope of testing (network/webapp/api).
            modules (list): List of modules to run.
            output_format (str): Output format (pdf/html/json).
            verbose (bool): Enable verbose output.
            auth_token (str): Authorization token.
        """
        self.target = target
        self.scope = scope
        self.modules = modules or []
        self.output_format = output_format
        self.verbose = verbose
        self.auth_token = auth_token
        self.console = Console()
        self.results = {
            "recon": {},
            "vulns": [],
            "exploits": [],
            "post_exploit": []
        }
        init(autoreset=True)
        
    def print_verbose(self, message: str) -> None:
        """Print verbose messages if verbose mode is enabled"""
        if self.verbose:
            try:
                self.console.print(f"[cyan][VERBOSE] {message}[/cyan]")
            except Exception as e:
                print(f"[VERBOSE] {message}")

    def banner(self):
        f = Figlet(font='slant')
        self.console.print(Panel.fit(f.renderText('AI PenTest'), title="Welcome", border_style="blue"))
        
    def show_help(self) -> None:
        """Display help information about available commands and modules."""
        """Display help information about available commands and modules"""
        help_table = Table(title="Available Commands and Modules")
        help_table.add_column("Command/Module", style="cyan")
        help_table.add_column("Description", style="green")
        
        # Commands
        help_table.add_row("--target", "Specify target IP/Domain")
        help_table.add_row("--scope", "Set scope (network/webapp/api)")
        help_table.add_row("--modules", "Select modules to run (comma-separated)")
        help_table.add_row("--output", "Set output format (pdf/html/json)")
        help_table.add_row("--verbose", "Enable verbose output")
        help_table.add_row("--help", "Show this help message")
        
        # Modules
        help_table.add_row("recon", "Passive and active reconnaissance")
        help_table.add_row("vuln_scan", "Vulnerability scanning")
        help_table.add_row("exploit", "Exploitation attempts")
        help_table.add_row("post_exploit", "Post-exploitation tasks")
        help_table.add_row("cleanup", "Cleanup operations")
        
        self.console.print(help_table)

    def validate_target(self, target: str) -> bool:
        """Validate target IP/Domain"""
        try:
            socket.gethostbyname(target)
            return True
        except socket.gaierror:
            self.console.print("[red]Invalid target IP/Domain[/red]")
            return False
        except Exception as e:
            self.console.print(f"[red]Error validating target: {str(e)}[/red]")
            return False

    def legal_compliance_check(self):
        """Verify authorization for the target (relaxed: only checks if token is present and valid for target)."""
        try:
            if not self.auth_token:
                self.console.print("[red]Error: No authorization token provided[/red]")
                return False

            # Only check if token is valid for the target (no strict format)
            if not self.validate_auth_token(self.auth_token):
                self.console.print("[red]Error: Authorization token is not valid for this target[/red]")
                return False

            self.print_verbose(f"Performing authorization check for target: {self.target}")
            return True
        except Exception as e:
            self.console.print(f"[red]Authorization verification failed: {str(e)}[/red]")
            return False

    def load_auth_tokens(self) -> dict:
        """Load authorization tokens from the JSON file"""
        try:
            script_dir = os.path.dirname(os.path.abspath(__file__))
            auth_file_path = os.path.join(script_dir, 'auth_tokens.json')
            with open(auth_file_path, 'r') as f:
                return json.load(f)
        except FileNotFoundError:
            self.console.print("[red]auth_tokens.json file not found![/red]")
            return {"tokens": []}
        except json.JSONDecodeError:
            self.console.print("[red]auth_tokens.json is not a valid JSON file![/red]")
            return {"tokens": []}
        except Exception as e:
            self.console.print(f"[red]Error loading auth tokens: {str(e)}[/red]")
            return {"tokens": []}

    def list_available_tokens(self) -> None:
        """Display available authorization tokens in a table."""
        """Display available authorization tokens"""
        auth_data = self.load_auth_tokens()
        
        # Create a table to display tokens
        table = Table(title="Available Authorization Tokens")
        table.add_column("Token", style="cyan")
        table.add_column("Description", style="green")
        table.add_column("Allowed Targets", style="yellow")
        
        for token_info in auth_data.get("tokens", []):
            targets = ", ".join(token_info.get("allowed_targets", []))
            table.add_row(
                token_info.get("token", ""),
                token_info.get("description", ""),
                targets
            )
        
        self.console.print(table)

    def validate_auth_token(self, token):
        """Validate the authorization token against the stored tokens"""
        auth_data = self.load_auth_tokens()
        
        for token_info in auth_data.get("tokens", []):
            if token_info.get("token") == token:
                allowed_targets = token_info.get("allowed_targets", [])
                # Check if token allows all targets or specific target is allowed
                if "*" in allowed_targets or self.target in allowed_targets:
                    return True
        return False

    def get_auth_token(self) -> str:
        """Get authorization token from environment or prompt user."""
        """Get authorization token with improved user interface"""
        # First try to get from environment variable
        auth_token = os.getenv('PENTEST_AUTH_TOKEN')
        
        if not auth_token:
            self.console.print("\n[yellow]Available Authorization Tokens:[/yellow]")
            self.list_available_tokens()
            
            # Let user choose from available tokens
            auth_data = self.load_auth_tokens()
            available_tokens = [t.get("token") for t in auth_data.get("tokens", [])]
            
            if available_tokens:
                token_number = Prompt.ask(
                    "\nEnter token number",
                    choices=[str(i+1) for i in range(len(available_tokens))],
                    default="1"
                )
                auth_token = available_tokens[int(token_number) - 1]
            else:
                self.console.print("[red]No authorization tokens available![/red]")
                return None
        
        self.auth_token = auth_token
        return auth_token

    def passive_recon(self) -> bool:
        """Perform passive reconnaissance"""
        self.console.print("[yellow]Starting Passive Reconnaissance...[/yellow]")
        try:
            # DNS Information
            self.print_verbose("Gathering DNS information...")
            try:
                dns_info = socket.gethostbyname_ex(self.target)
                self.results["recon"]["dns"] = dns_info
            except Exception as e:
                self.print_verbose(f"DNS info failed: {str(e)}")
                self.results["recon"]["dns"] = str(e)

            # WHOIS Information
            self.print_verbose("Performing WHOIS lookup...")
            try:
                whois_info = whois.whois(self.target)
                self.results["recon"]["whois"] = whois_info
            except Exception as e:
                self.print_verbose(f"WHOIS lookup failed: {str(e)}")
                self.results["recon"]["whois"] = str(e)

            # HTTP Information
            self.print_verbose("Gathering HTTP information...")
            try:
                response = requests.get(f"http://{self.target}", timeout=10)
                self.results["recon"]["http_status"] = response.status_code
                self.results["recon"]["http_headers"] = dict(response.headers)
                self.results["recon"]["server_info"] = response.headers.get('Server')
            except requests.exceptions.RequestException as e:
                self.print_verbose(f"HTTP request failed: {str(e)}")
                self.results["recon"]["http_status"] = "Connection Failed"
            except Exception as e:
                self.print_verbose(f"HTTP info error: {str(e)}")
                self.results["recon"]["http_status"] = str(e)

            # Shodan Integration
            if os.getenv('SHODAN_API_KEY'):
                self.print_verbose("Querying Shodan...")
                try:
                    api = shodan.Shodan(os.getenv('SHODAN_API_KEY'))
                    shodan_info = api.host(self.target)
                    self.results["recon"]["shodan"] = shodan_info
                except Exception as e:
                    self.print_verbose(f"Shodan query failed: {str(e)}")
                    self.results["recon"]["shodan"] = str(e)

            return True
        except Exception as e:
            self.console.print(f"[red]Passive reconnaissance failed: {str(e)}[/red]")
            return False

    def active_recon(self) -> bool:
        """Perform active reconnaissance"""
        self.console.print("[yellow]Starting Active Reconnaissance...[/yellow]")
        try:
            # Port Scanning
            self.print_verbose("Starting port scan...")
            try:
                nm = nmap.PortScanner()
                scan_results = nm.scan(self.target, arguments="-sV -sS -T4 -F")
                self.results["recon"]["nmap"] = scan_results
            except Exception as e:
                self.print_verbose(f"Nmap scan failed: {str(e)}")
                self.results["recon"]["nmap"] = str(e)

            # Service Version Detection
            scan_results = self.results["recon"].get("nmap", {})
            if isinstance(scan_results, dict) and 'scan' in scan_results:
                for host in scan_results['scan']:
                    if 'tcp' in scan_results['scan'][host]:
                        for port in scan_results['scan'][host]['tcp']:
                            service_info = scan_results['scan'][host]['tcp'][port]
                            self.print_verbose(f"Port {port}: {service_info.get('name', 'unknown')} "
                                            f"({service_info.get('version', 'unknown')})")

            return True
        except Exception as e:
            self.console.print(f"[red]Active reconnaissance failed: {str(e)}[/red]")
            return False

    def vulnerability_scan(self):
        """Perform vulnerability scanning"""
        self.console.print("[yellow]Starting Vulnerability Scan...[/yellow]")
        
        try:
            self.print_verbose("Initializing vulnerability scanner...")
            
            # Web Application Vulnerabilities
            if 'webapp' in self.scope:
                self.print_verbose("Scanning for web vulnerabilities...")
                web_vulns = self.scan_web_vulnerabilities()
                self.results["vulns"].extend(web_vulns)

            # Network Vulnerabilities
            if 'network' in self.scope:
                self.print_verbose("Scanning for network vulnerabilities...")
                network_vulns = self.scan_network_vulnerabilities()
                self.results["vulns"].extend(network_vulns)

            # API Vulnerabilities
            if 'api' in self.scope:
                self.print_verbose("Scanning for API vulnerabilities...")
                api_vulns = self.scan_api_vulnerabilities()
                self.results["vulns"].extend(api_vulns)

            return True
        except Exception as e:
            self.console.print(f"[red]Vulnerability scanning failed: {str(e)}[/red]")
            return False

    def scan_web_vulnerabilities(self) -> list:
        """
        Scan for basic web application vulnerabilities:
        - Missing security headers
        - Open directory listing
        Returns:
            list: List of found vulnerabilities (dicts)
        """
        vulns = []
        url = f"http://{self.target}"
        try:
            response = requests.get(url, timeout=10)
            headers = response.headers
            # Check for missing security headers
            required_headers = [
                "Content-Security-Policy",
                "Strict-Transport-Security",
                "X-Frame-Options",
                "X-Content-Type-Options",
                "Referrer-Policy",
                "Permissions-Policy"
            ]
            for header in required_headers:
                if header not in headers:
                    vulns.append({
                        "name": f"Missing Security Header: {header}",
                        "description": f"The HTTP response is missing the {header} header.",
                        "severity": "Low",
                        "evidence": dict(headers)
                    })
            # Check for open directory listing
            if "Index of /" in response.text and response.status_code == 200:
                vulns.append({
                    "name": "Open Directory Listing",
                    "description": "The web server allows directory listing, which can leak sensitive files.",
                    "severity": "High",
                    "evidence": url
                })
        except Exception as e:
            self.print_verbose(f"Web vuln scan failed: {str(e)}")
        return vulns

    def scan_network_vulnerabilities(self) -> list:
        """
        Scan for network vulnerabilities.
        Extend this method to add custom network vulnerability scanning logic.
        Returns:
            list: List of found vulnerabilities (dicts)
        """
        vulns = []
        # TODO: Implement or plug in your network vulnerability scanner here.
        return vulns

    def scan_api_vulnerabilities(self) -> list:
        """
        Scan for API vulnerabilities.
        Extend this method to add custom API vulnerability scanning logic.
        Returns:
            list: List of found vulnerabilities (dicts)
        """
        vulns = []
        # TODO: Implement or plug in your API vulnerability scanner here.
        return vulns

    def exploitation(self) -> bool:
        """
        Perform exploitation if vulnerabilities are found.
        Extend this method to add custom exploitation logic.
        Returns:
            bool: True if exploitation attempted, False otherwise.
        """
        if not self.results["vulns"]:
            self.console.print("[yellow]No vulnerabilities found to exploit[/yellow]")
            return False

        self.console.print("[yellow]Starting Exploitation Phase...[/yellow]")
        self.print_verbose(f"Found {len(self.results['vulns'])} potential vulnerabilities")
        # TODO: Implement or plug in your exploitation logic here.
        for vuln in self.results["vulns"]:
            self.print_verbose(f"Attempting to exploit: {vuln.get('name', 'Unknown vulnerability')}")
            # Example: result = exploit_vuln(vuln)
            # self.results['exploits'].append(result)
        return True

    def post_exploitation(self) -> bool:
        """
        Perform post-exploitation tasks.
        Extend this method to add custom post-exploitation logic.
        Returns:
            bool: True if post-exploitation attempted, False otherwise.
        """
        self.console.print("[yellow]Starting Post-Exploitation Phase...[/yellow]")
        if not self.results["exploits"]:
            self.print_verbose("No successful exploits to perform post-exploitation")
            return False
        # TODO: Implement or plug in your post-exploitation logic here.
        return True

    def cleanup(self) -> bool:
        """Perform cleanup operations and return True if successful."""
        """Perform cleanup operations"""
        self.console.print("[yellow]Starting Cleanup Phase...[/yellow]")
        
        try:
            self.print_verbose("Removing temporary files...")
            # Add cleanup logic here
            
            self.print_verbose("Closing connections...")
            # Add connection cleanup logic here
            
            return True
        except Exception as e:
            self.console.print(f"[red]Cleanup failed: {str(e)}[/red]")
            return False

    def generate_report(self) -> bool:
        """Generate the final report in the selected format."""
        self.console.print("[yellow]Generating Report...[/yellow]")

        def convert(obj):
            if isinstance(obj, datetime):
                return obj.isoformat()
            if isinstance(obj, dict):
                return {k: convert(v) for k, v in obj.items()}
            if isinstance(obj, list):
                return [convert(i) for i in obj]
            return obj

        report_data = {
            "target": self.target,
            "scan_date": datetime.now().isoformat(),
            "scope": self.scope,
            "modules_run": self.modules,
            "results": convert(self.results)
        }

        filename = f"pentest_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}"

        if self.output_format == 'json':
            with open(f"{filename}.json", 'w') as f:
                json.dump(report_data, f, indent=4)

        elif self.output_format == 'html':
            self.generate_html_report(report_data, filename)

        elif self.output_format == 'pdf':
            self.generate_pdf_report(report_data, filename)

        self.console.print(f"[green]Report generated: {filename}.{self.output_format}[/green]")
        return True

    def generate_html_report(self, data: dict, filename: str) -> None:
        """Generate HTML report with summary and recommendations."""
        try:
            html = f"""
            <html><head><title>Penetration Test Report</title></head><body>
            <h1>Penetration Test Report</h1>
            <h2>Target: {data.get('target')}</h2>
            <h3>Scan Date: {data.get('scan_date')}</h3>
            <h3>Scope: {data.get('scope')}</h3>
            <h3>Modules Run: {', '.join(data.get('modules_run', []))}</h3>
            <h2>Summary</h2>
            <pre>{json.dumps(data.get('results', {}), indent=2)}</pre>
            <h2>Recommendations</h2>
            <ul>
                <li>Review all findings and address critical vulnerabilities immediately.</li>
                <li>Ensure all software is up to date.</li>
                <li>Implement least privilege and strong authentication.</li>
                <li>Monitor logs for suspicious activity.</li>
            </ul>
            </body></html>
            """
            with open(f"{filename}.html", "w", encoding="utf-8") as f:
                f.write(html)
        except Exception as e:
            self.console.print(f"[red]Failed to generate HTML report: {str(e)}[/red]")

    def generate_pdf_report(self, data: dict, filename: str) -> None:
        """Generate PDF report with summary and recommendations."""
        try:
            from reportlab.lib.pagesizes import letter
            from reportlab.pdfgen import canvas
            pdf_file = f"{filename}.pdf"
            c = canvas.Canvas(pdf_file, pagesize=letter)
            width, height = letter
            y = height - 40
            c.setFont("Helvetica-Bold", 16)
            c.drawString(40, y, "Penetration Test Report")
            y -= 30
            c.setFont("Helvetica", 12)
            c.drawString(40, y, f"Target: {data.get('target')}")
            y -= 20
            c.drawString(40, y, f"Scan Date: {data.get('scan_date')}")
            y -= 20
            c.drawString(40, y, f"Scope: {data.get('scope')}")
            y -= 20
            c.drawString(40, y, f"Modules Run: {', '.join(data.get('modules_run', []))}")
            y -= 30
            c.setFont("Helvetica-Bold", 14)
            c.drawString(40, y, "Summary:")
            y -= 20
            c.setFont("Helvetica", 10)
            summary = json.dumps(data.get('results', {}), indent=2)
            for line in summary.splitlines():
                if y < 60:
                    c.showPage()
                    y = height - 40
                    c.setFont("Helvetica", 10)
                c.drawString(40, y, line[:90])
                y -= 12
            y -= 20
            c.setFont("Helvetica-Bold", 14)
            c.drawString(40, y, "Recommendations:")
            y -= 20
            c.setFont("Helvetica", 10)
            recs = [
                "Review all findings and address critical vulnerabilities immediately.",
                "Ensure all software is up to date.",
                "Implement least privilege and strong authentication.",
                "Monitor logs for suspicious activity."
            ]
            for rec in recs:
                if y < 60:
                    c.showPage()
                    y = height - 40
                    c.setFont("Helvetica", 10)
                c.drawString(60, y, f"- {rec}")
                y -= 12
            c.save()
        except Exception as e:
            self.console.print(f"[red]Failed to generate PDF report: {str(e)}[/red]")

    def load_allowed_targets(self) -> list:
        """Load allowed targets from configuration (stub for demo)."""
        """Load allowed targets from configuration"""
        # This would typically load from a secure configuration file
        # For demo purposes, returning a sample list
        return ["example.com", "test.local", "127.0.0.1"]

    def run(self):
        """Main execution flow"""
        self.banner()

        if not self.target:
            self.target = Prompt.ask("Enter target (IP/Domain)")
        
        if not self.validate_target(self.target):
            return False

        if not self.scope:
            self.scope = Prompt.ask("Enter scope", choices=["network", "webapp", "api"])
            
        if not self.modules:
            available_modules = ["recon", "vuln_scan", "exploit", "post_exploit", "cleanup"]
            self.modules = Prompt.ask("Enter modules (comma-separated)", default=",".join(available_modules))
            if isinstance(self.modules, str):
                self.modules = [m.strip() for m in self.modules.split(",")]

        if not self.output_format:
            self.output_format = Prompt.ask("Enter output format", choices=["pdf", "html", "json"], default="json")

        # Get and validate authorization token
        if not self.auth_token:
            self.get_auth_token()

        # Legal Compliance Check
        if not self.legal_compliance_check():
            self.console.print("[red]Terminating: Legal compliance check failed[/red]")
            return False

        # Execute phases
        phases = [
            ("Passive Reconnaissance", self.passive_recon, "recon"),
            ("Active Reconnaissance", self.active_recon, "recon"),
            ("Vulnerability Scanning", self.vulnerability_scan, "vuln_scan"),
            ("Exploitation", self.exploitation, "exploit"),
            ("Post-Exploitation", self.post_exploitation, "post_exploit"),
            ("Cleanup", self.cleanup, "cleanup"),
            ("Report Generation", self.generate_report, None)
        ]

        with Progress() as progress:
            task = progress.add_task("[cyan]Running penetration test...", total=len(phases))

            for phase_name, phase_func, module in phases:
                if module is None or module in self.modules:
                    self.console.print(f"\n[blue]Executing {phase_name}...[/blue]")
                    if not phase_func():
                        self.console.print(f"[red]{phase_name} failed![/red]")
                    else:
                        self.print_verbose(f"{phase_name} completed successfully")
                progress.update(task, advance=1)

        self.console.print("[green]Penetration test completed![/green]")
        return True

def main():
    parser = argparse.ArgumentParser(description='AI-Powered Penetration Testing Tool')
    parser.add_argument('--target', help='Target IP/Domain')
    parser.add_argument('--scope', choices=['network', 'webapp', 'api'], help='Scope of testing')
    parser.add_argument('--modules', help='Modules to run (comma-separated)')
    parser.add_argument('--output', choices=['pdf', 'html', 'json'], default='json', help='Output format')
    parser.add_argument('--verbose', action='store_true', help='Enable verbose output')
    parser.add_argument('--help-modules', action='store_true', help='Show detailed help about available modules')
    parser.add_argument('--auth-token', help='Authorization token (format: AUTH-YYYY-MM-DD-XXXX)')
    parser.add_argument('--demo', action='store_true', help='Quickstart demo mode (skips legal checks, uses test target)')
    parser.add_argument('--list-modules', action='store_true', help='List available modules and exit')
    parser.add_argument('--list-tokens', action='store_true', help='List available authorization tokens and exit')
    args = parser.parse_args()

    if args.list_modules:
        print("Available modules:")
        for m in ["recon", "vuln_scan", "exploit", "post_exploit", "cleanup"]:
            print(f"- {m}")
        return

    if args.list_tokens:
        pentest = PentestAutomation()
        pentest.list_available_tokens()
        return
        demo_output = os.getenv('PENETEST_DEMO_OUTPUT', 'json')
        demo_token = os.getenv('PENETEST_DEMO_TOKEN', 'AUTH-2025-12-31-1234')
        pentest = PentestAutomation(
            target=demo_target,
            scope=demo_scope,
            modules=demo_modules,
            output_format=demo_output,
            verbose=True,
            auth_token=demo_token
        )
        # Monkey-patch legal_compliance_check to always pass in demo mode
        pentest.legal_compliance_check = lambda: True
        pentest.run()
        return

    # Allow config from environment variables if not provided
    target = args.target or os.getenv('PENETEST_TARGET')
    scope = args.scope or os.getenv('PENETEST_SCOPE')
    modules = args.modules.split(',') if args.modules else (
        os.getenv('PENETEST_MODULES').split(',') if os.getenv('PENETEST_MODULES') else None)
    output_format = args.output or os.getenv('PENETEST_OUTPUT', 'json')
    auth_token = args.auth_token or os.getenv('PENETEST_AUTH_TOKEN')

    pentest = PentestAutomation(
        target=target,
        scope=scope,
        modules=modules,
        output_format=output_format,
        verbose=args.verbose,
        auth_token=auth_token
    )
    pentest.run()

if __name__ == "__main__":
    main()
